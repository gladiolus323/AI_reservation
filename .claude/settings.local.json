{
  "permissions": {
    "allow": [
      "Bash(python:*)",
      "Bash(where:*)",
      "Bash(python3:*)",
      "Bash(py -c:*)",
      "Bash(py -m pip install:*)",
      "Bash(powershell -Command \"& {[System.IO.Compression.ZipFile]::OpenRead\\(''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\master.xlsx''\\).Entries | ForEach-Object { $_Name }}\")",
      "Bash(powershell -Command \"Add-Type -AssemblyName System.IO.Compression.FileSystem; $zip = [System.IO.Compression.ZipFile]::OpenRead\\(''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\master.xlsx''\\); $entry = $zip.GetEntry\\(''xl/sharedStrings.xml''\\); $stream = $entry.Open\\(\\); $reader = New-Object System.IO.StreamReader\\($stream\\); $content = $reader.ReadToEnd\\(\\); $reader.Close\\(\\); $zip.Dispose\\(\\); $content\")",
      "Bash(powershell -Command:*)",
      "Bash(powershell:*)",
      "Bash(chcp 6500)",
      "Bash(dir \"c:\\\\temp\\\\xlsx_extract\" /s /b)",
      "Bash(move \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\patient_schedule.csv\" \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\pre_synthetic_data\"\" && move \"c:UsersuserDesktop검사규칙 합성데이터resource_schedule.csv\" \"c:UsersuserDesktop검사규칙 합성데이터pre_synthetic_data\"\")",
      "Bash(move \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\constraints.csv\" \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\pre_synthetic_data\"\" && move \"c:UsersuserDesktop검사규칙 합성데이터source.xlsx\" \"c:UsersuserDesktop검사규칙 합성데이터pre_synthetic_data\"\")",
      "Bash(move \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\정형화_분석_보고서.md\" \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\docs\"\" && move \"c:UsersuserDesktop검사규칙 합성데이터스키마_미커버_규칙_보고서.md\" \"c:UsersuserDesktop검사규칙 합성데이터docs\"\")",
      "Bash(py:*)",
      "Bash(Select-String -Pattern \"<t>[^<]+\" -AllMatches)",
      "Bash(ForEach-Object { $_Matches.Value })",
      "Bash(Select-Object -First 50)",
      "Bash(del \"c:\\\\temp\\\\read_xlsx.ps1\")",
      "Bash(del \"c:\\\\temp\\\\read_xlsx2.ps1\")",
      "Bash(del \"c:\\\\temp\\\\read_xlsx3.ps1\")",
      "Bash(del \"c:\\\\temp\\\\compare_duration.py\")",
      "Bash(del \"c:\\\\temp\\\\check_duration_integrity.py\")",
      "Bash(del \"c:\\\\temp\\\\read_source_xlsx.py\")",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\ctempread_xlsx.ps1\")",
      "Bash(C:Miniconda3python.exe -c \"\nimport pandas as pd\n\n# xlsx 파일 읽기\nxlsx = pd.ExcelFile\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\pre_synthetic_data\\\\source.xlsx''\\)\n\n# 시트 목록 출력\nprint\\(''=== 시트 목록 ===''\\)\nprint\\(xlsx.sheet_names\\)\nprint\\(\\)\n\n# 각 시트별 정보\nfor sheet in xlsx.sheet_names:\n    df = pd.read_excel\\(xlsx, sheet_name=sheet\\)\n    print\\(f''=== {sheet} ===''\\)\n    print\\(f''행 수: {len\\(df\\)}''\\)\n    print\\(f''컬럼: {list\\(df.columns\\)}''\\)\n    print\\(\\)\n    print\\(''처음 5행:''\\)\n    print\\(df.head\\(5\\).to_string\\(\\)\\)\n    print\\(\\)\n    print\\(''---''\\)\n\")",
      "Bash(C:\\\\Miniconda3\\\\python.exe -c:*)",
      "Bash(C:Miniconda3python.exe \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\temp_check_func_master.py\")",
      "Bash(C:Miniconda3python.exe -c \"\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION.csv''\\)\nexam_master = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER.csv''\\)\nrelation_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES.csv''\\)\ncondition_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES.csv''\\)\n\nreservation[''RESERVATION_DATE''] = pd.to_datetime\\(reservation[''RESERVATION_DATE'']\\)\nreservation[''RESERVATION_DATETIME''] = pd.to_datetime\\(reservation[''RESERVATION_DATETIME'']\\)\nreservation[''ORDER_DATE''] = pd.to_datetime\\(reservation[''ORDER_DATE'']\\)\nreservation[''WEEKDAY''] = reservation[''RESERVATION_DATE''].dt.day_name\\(\\)\nreservation[''MONTH''] = reservation[''RESERVATION_DATE''].dt.month\n\nprint\\(''=''*70\\)\nprint\\(''1. 기본 통계''\\)\nprint\\(''=''*70\\)\nprint\\(f''총 예약 건수: {len\\(reservation\\):,}건''\\)\nprint\\(f''총 환자 수: {reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):,}명''\\)\nprint\\(f''사용된 검사 코드: {reservation[\"\"EXAM_CD\"\"].nunique\\(\\)}개 / {len\\(exam_master\\)}개''\\)\nprint\\(f''예약 기간: {reservation[\"\"RESERVATION_DATE\"\"].min\\(\\).strftime\\(\"\"%Y-%m-%d\"\"\\)} ~ {reservation[\"\"RESERVATION_DATE\"\"].max\\(\\).strftime\\(\"\"%Y-%m-%d\"\"\\)}''\\)\nprint\\(f''환자당 평균 예약: {len\\(reservation\\)/reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):.2f}건''\\)\n\n# 장비별 통계\nprint\\(f''\\\\n장비유형별 예약 건수:''\\)\nequip_counts = reservation[''EQUIPMENT_TYPE''].value_counts\\(\\)\nfor eq, cnt in equip_counts.items\\(\\):\n    print\\(f''  {eq}: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\")",
      "Bash(C:\\\\\\\\Miniconda3\\\\\\\\python.exe:*)",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\eda_reservation.py\")",
      "Bash(C:Miniconda3python.exe \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\src\\\\generate_schedule_html.py\")",
      "Bash(move:*)",
      "Bash(C:Miniconda3python.exe -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION.csv''\\)\nexam_master = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER.csv''\\)\nresource = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESOURCE.csv''\\)\n\nreservation[''RESERVATION_DATE''] = pd.to_datetime\\(reservation[''RESERVATION_DATE'']\\)\nreservation[''WEEKDAY''] = reservation[''RESERVATION_DATE''].dt.day_name\\(\\)\n\nprint\\(''=== 기본 통계 ===''\\)\nprint\\(f''총 예약 건수: {len\\(reservation\\):,}''\\)\nprint\\(f''총 환자 수: {reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):,}''\\)\nprint\\(f''사용된 검사 코드: {reservation[\"\"EXAM_CD\"\"].nunique\\(\\)} / {len\\(exam_master\\)}''\\)\nprint\\(f''예약 기간: {reservation[\"\"RESERVATION_DATE\"\"].min\\(\\).strftime\\(\"\"%Y-%m-%d\"\"\\)} ~ {reservation[\"\"RESERVATION_DATE\"\"].max\\(\\).strftime\\(\"\"%Y-%m-%d\"\"\\)}''\\)\nprint\\(f''환자당 평균 예약: {len\\(reservation\\)/reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):.2f}건''\\)\n\nprint\\(''\\\\n=== 장비별 예약 ===''\\)\nequip = reservation[''EQUIPMENT_TYPE''].value_counts\\(\\)\nfor eq, cnt in equip.items\\(\\):\n    print\\(f''{eq}: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\nprint\\(''\\\\n=== 요일별 예약 ===''\\)\nweekday_order = [''Monday'', ''Tuesday'', ''Wednesday'', ''Thursday'', ''Friday'', ''Saturday'', ''Sunday'']\nweekday = reservation[''WEEKDAY''].value_counts\\(\\).reindex\\(weekday_order\\)\nfor wd, cnt in weekday.items\\(\\):\n    if pd.notna\\(cnt\\):\n        print\\(f''{wd}: {int\\(cnt\\):,}건 \\({int\\(cnt\\)/len\\(reservation\\)*100:.1f}%\\)''\\)\n\nprint\\(''\\\\n=== 자원 현황 ===''\\)\nfor _, r in resource.groupby\\(''EQUIPMENT_TYPE''\\).size\\(\\).items\\(\\):\n    pass\nresource_summary = resource.groupby\\(''EQUIPMENT_TYPE''\\).size\\(\\)\nfor eq, cnt in resource_summary.items\\(\\):\n    print\\(f''{eq}: {cnt}대''\\)\nprint\\(f''총: {len\\(resource\\)}대''\\)\n\nprint\\(''\\\\n=== 시간대별 예약 ===''\\)\nreservation[''HOUR''] = pd.to_datetime\\(reservation[''RESERVATION_TIME'']\\).dt.hour\nhour_dist = reservation[''HOUR''].value_counts\\(\\).sort_index\\(\\)\nfor h, cnt in hour_dist.items\\(\\):\n    print\\(f''{h:02d}시: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\")",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\temp_stats.py\")",
      "Bash(C:\\\\Miniconda3\\\\python.exe:*)",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\docs\\\\프로젝트_개요.md\")",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\docs\\\\프로젝트_구현_현황.md\")",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\docs\\\\정형화_분석_보고서.md\")",
      "Bash(del \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\docs\\\\스키마_미커버_규칙_보고서.md\")",
      "Bash(C:Miniconda3python.exe \"c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\src\\\\rule_engine.py\")",
      "Bash(C:Miniconda3python.exe -c \"import os; folder = r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\schema''; files = [''EXAM_MASTER.csv'', ''EXAM_RELATION_RULES.csv'', ''EXAM_CONDITION_RULES.csv'']; [open\\(os.path.join\\(folder, f\\), ''r'', encoding=''utf-8''\\).read\\(\\) for f in files]; [\\(lambda content=open\\(os.path.join\\(folder, f\\), ''r'', encoding=''utf-8''\\).read\\(\\): open\\(os.path.join\\(folder, f\\), ''w'', encoding=''utf-8-sig''\\).write\\(content\\)\\)\\(\\) for f in files]; print\\(''모든 CSV 파일에 UTF-8 BOM 추가 완료''\\)\")",
      "Bash(dir:*)",
      "Bash(C:Miniconda3python.exe -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nmaster = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER.csv''\\)\ncondition = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES.csv''\\)\nrelation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES.csv''\\)\n\nprint\\(''=== 규칙 데이터 현황 ===''\\)\nprint\\(f''EXAM_MASTER: {len\\(master\\)}건''\\)\nprint\\(f''EXAM_CONDITION_RULES: {len\\(condition\\)}건''\\)\nprint\\(f''EXAM_RELATION_RULES: {len\\(relation\\)}건''\\)\n\nprint\\(''\\\\n=== EXAM_MASTER 장비별 분포 ===''\\)\nequip = master[''EQUIPMENT_TYPE''].value_counts\\(\\)\nfor eq, cnt in equip.items\\(\\):\n    print\\(f''{eq}: {cnt}개''\\)\n\nprint\\(''\\\\n=== EXAM_CONDITION_RULES 유형별 ===''\\)\ncond_type = condition[''COND_TYPE''].value_counts\\(\\)\nfor ct, cnt in cond_type.items\\(\\):\n    print\\(f''{ct}: {cnt}건''\\)\n\nprint\\(''\\\\n=== EXAM_CONDITION_RULES ACTION별 ===''\\)\naction = condition[''ACTION_CD''].value_counts\\(\\)\nfor ac, cnt in action.items\\(\\):\n    print\\(f''{ac}: {cnt}건''\\)\n\nprint\\(''\\\\n=== EXAM_RELATION_RULES 분석 ===''\\)\nprint\\(f''SEQ_REQ_YN=Y \\(순서필수\\): {len\\(relation[relation[\"\"SEQ_REQ_YN\"\"]==\"\"Y\"\"]\\)}건''\\)\nprint\\(f''SAME_DAY_CD=N \\(당일불가\\): {len\\(relation[relation[\"\"SAME_DAY_CD\"\"]==\"\"N\"\"]\\)}건''\\)\nprint\\(f''SAME_DAY_CD=Y \\(당일필수\\): {len\\(relation[relation[\"\"SAME_DAY_CD\"\"]==\"\"Y\"\"]\\)}건''\\)\nprint\\(f''SAME_DAY_CD=C \\(당일가능\\): {len\\(relation[relation[\"\"SAME_DAY_CD\"\"]==\"\"C\"\"]\\)}건''\\)\nprint\\(f''GAP_VALUE 있음: {relation[\"\"GAP_VALUE\"\"].notna\\(\\).sum\\(\\)}건''\\)\n\nprint\\(''\\\\n=== REASON_CD 분포 ===''\\)\nreason = relation[''REASON_CD''].value_counts\\(dropna=False\\)\nfor r, cnt in reason.items\\(\\):\n    print\\(f''{r}: {cnt}건''\\)\n\")",
      "Bash(mkdir:*)",
      "Bash(rm:*)",
      "Bash(\"/c/Miniconda3/python.exe\" -c:*)",
      "Bash(\"/c/Miniconda3/python.exe\" \"c:/Users/user/Desktop/검사규칙 합성데이터/src/test_phase1.py\")",
      "Bash(\"/c/Miniconda3/python.exe\" \"c:/Users/user/Desktop/검사규칙 합성데이터/src/test_phase2.py\")",
      "Bash(\"/c/Miniconda3/python.exe\" \"c:/Users/user/Desktop/검사규칙 합성데이터/src/test_phase3.py\")",
      "Bash(\"/c/Miniconda3/python.exe\":*)",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nxlsx_path = r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\테이블 구조_검사세트 테이블사용\\(안동개발기기준\\)_교정본.xlsx''\n\n# 샘플데이터 시트 읽기 - 상세 데이터 확인\ndf = pd.read_excel\\(xlsx_path, sheet_name=''샘플데이터'', header=2\\)\n\n# 첫 행\\(헤더 설명\\) 제거\ndf = df.iloc[1:]\n\n# 상세 데이터 \\(A, B 타입\\) 확인 - 다른 컬럼에 있을 수 있음\nprint\\(''=== 샘플데이터 - 상세 레코드 구조 분석 ===''\\)\nprint\\(\\)\n\n# 마스터 이후 데이터 확인 \\(17행 이후\\)\nprint\\(''행 17~30 데이터:''\\)\nsubset = pd.read_excel\\(xlsx_path, sheet_name=''샘플데이터''\\)\nprint\\(subset.iloc[17:35].to_string\\(\\)\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nxlsx_path = r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\테이블 구조_검사세트 테이블사용\\(안동개발기기준\\)_교정본.xlsx''\n\n# 샘플데이터 시트 - 상세 데이터 부분 읽기 \\(헤더가 23행에 있음\\)\ndf = pd.read_excel\\(xlsx_path, sheet_name=''샘플데이터'', header=23\\)\ndf = df.iloc[:, 1:]  # 첫 번째 빈 컬럼 제거\n\nprint\\(''=== 검사세트 상세 데이터 \\(MSCEXMSD\\) ===''\\)\nprint\\(f''총 행수: {len\\(df\\)}''\\)\nprint\\(f''컬럼: {list\\(df.columns\\)}''\\)\nprint\\(\\)\n\n# SORD_DTL_TP_CD 분포\nprint\\(''SORD_DTL_TP_CD \\(상세구분코드\\) 분포:''\\)\nprint\\(''A: 상위코드리스트 \\(선행 검사\\)''\\)\nprint\\(''B: 하위 대응 코드리스트 \\(후행 검사\\)''\\)\nprint\\(\\)\ntp_counts = df[''SORD_DTL_TP_CD''].value_counts\\(\\)\nfor tp, cnt in tp_counts.items\\(\\):\n    print\\(f''  {tp}: {cnt}건''\\)\n\nprint\\(\\)\nprint\\(''세트별 상세 건수:''\\)\nset_counts = df.groupby\\(''SORD_REG_ID''\\).size\\(\\).sort_index\\(\\)\nfor set_id, cnt in set_counts.items\\(\\):\n    print\\(f''  {set_id}: {cnt}건''\\)\n\nprint\\(\\)\nprint\\(''=== 세트별 A/B 분포 ===''\\)\npivot = df.groupby\\([''SORD_REG_ID'', ''SORD_DTL_TP_CD'']\\).size\\(\\).unstack\\(fill_value=0\\)\nprint\\(pivot.to_string\\(\\)\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nxlsx_path = r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\테이블 구조_검사세트 테이블사용\\(안동개발기기준\\)_교정본.xlsx''\n\n# 샘플데이터 시트에서 마스터 데이터 읽기\ndf_master = pd.read_excel\\(xlsx_path, sheet_name=''샘플데이터'', header=2, nrows=16\\)\ndf_master = df_master.iloc[:, 1:]  # 첫 번째 빈 컬럼 제거\n\nprint\\(''=== 마스터 데이터 \\(MSCEXMSM\\) ===''\\)\nprint\\(df_master.to_string\\(\\)\\)\nprint\\(\\)\n\n# SORD_TP_CD별 분포\nprint\\(''=== SORD_TP_CD 분포 ===''\\)\nprint\\(df_master[''SORD_TP_CD''].value_counts\\(\\).sort_index\\(\\)\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\ncondition = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''조건 규칙 상세 분석 - 매뉴얼 규칙 vs 테이블 레코드''\\)\nprint\\(''=''*70\\)\nprint\\(\\)\n\n# 테이블 레코드 기준\nprint\\(''1. 테이블 레코드 기준 \\(47건\\)''\\)\nprint\\(''-''*50\\)\nscheduling_actions = [''TIMEONLY'', ''NOWEEKEND'']\nscheduling_records = condition[condition[''ACTION_CD''].isin\\(scheduling_actions\\)]\nbilling_records = condition[condition[''ACTION_VAL''].astype\\(str\\).str.contains\\(''비급여''\\)]\ninfo_records = condition[~condition[''ACTION_CD''].isin\\(scheduling_actions\\) & ~condition[''ACTION_VAL''].astype\\(str\\).str.contains\\(''비급여''\\)]\n\nprint\\(f''  스케줄링: {len\\(scheduling_records\\)}건 \\(TIMEONLY 13 + NOWEEKEND 5\\)''\\)\nprint\\(f''  안내/준비: {len\\(info_records\\)}건''\\)\nprint\\(f''  과금: {len\\(billing_records\\)}건''\\)\nprint\\(f''  합계: {len\\(scheduling_records\\) + len\\(info_records\\) + len\\(billing_records\\)}건''\\)\nprint\\(\\)\n\n# RULE_ID 기준 \\(매뉴얼 규칙 수\\)\nprint\\(''2. RULE_ID 기준 - 매뉴얼 고유 규칙 수 \\(20개\\)''\\)\nprint\\(''-''*50\\)\nscheduling_rules = scheduling_records[''RULE_ID''].unique\\(\\)\nbilling_rules = billing_records[''RULE_ID''].unique\\(\\)\ninfo_rules = info_records[''RULE_ID''].unique\\(\\)\n\nprint\\(f''  스케줄링: {len\\(scheduling_rules\\)}개''\\)\nprint\\(f''  안내/준비: {len\\(info_rules\\)}개''\\)\nprint\\(f''  과금: {len\\(billing_rules\\)}개''\\)\nprint\\(f''  합계: {len\\(scheduling_rules\\) + len\\(info_rules\\) + len\\(billing_rules\\)}개''\\)\nprint\\(\\)\n\n# 문서에서의 조건규칙 29개 = RULE_ID 20개가 아님\n# 문서의 29개는 어디서 나온 건지 확인\nprint\\(''3. 문서 기재값 \"\"조건 규칙 29개\"\" 근거 확인''\\)\nprint\\(''-''*50\\)\nprint\\(''  문서: 정형화 완료 100개 = 관계50 + 조건29 + 속성21''\\)\nprint\\(''  실제 테이블: EXAM_CONDITION_RULES = 47건''\\)\nprint\\(''  실제 RULE_ID: 20개''\\)\nprint\\(\\)\nprint\\(''  → 문서의 29개는 \"\"매뉴얼에서 추출한 조건부 규칙 수\"\"''\\)\nprint\\(''  → 테이블 47건은 \"\"검사코드별로 확장한 레코드 수\"\"''\\)\nprint\\(''  → RULE_ID 20개는 \"\"실제 구현된 고유 규칙 유형 수\"\"''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nrelation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''관계 규칙 분석 - 문서 50개 vs 실제 86건''\\)\nprint\\(''=''*70\\)\nprint\\(\\)\nprint\\(f''실제 테이블 레코드: {len\\(relation\\)}건''\\)\nprint\\(f''문서 기재: 50개''\\)\nprint\\(\\)\nprint\\(''→ 문서의 50개는 \"\"매뉴얼에서 추출한 관계 규칙 수\"\"''\\)\nprint\\(''→ 테이블 86건은 \"\"검사쌍별로 확장한 레코드 수\"\"''\\)\nprint\\(\\)\n\n# 검사 속성은 어떻게 21개인지\nprint\\(''=''*70\\)\nprint\\(''검사 속성 규칙 21개 근거''\\)\nprint\\(''=''*70\\)\nprint\\(\\)\nprint\\(''EXAM_MASTER에서 규칙으로 활용되는 속성:''\\)\nprint\\(''  - DURATION_MIN \\(소요시간\\)''\\)\nprint\\(''  - FASTING_HRS \\(금식시간\\)''\\)  \nprint\\(''  - AVAIL_START_TIME/AVAIL_END_TIME \\(가용시간\\)''\\)\nprint\\(''  - CONTRAST_YN \\(조영제\\)''\\)\nprint\\(''  - SEDATION_YN \\(진정\\)''\\)\nprint\\(\\)\nprint\\(''→ 문서의 21개는 \"\"매뉴얼에서 추출한 검사 속성 관련 규칙 수\"\"''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nprint\\(''=''*80\\)\nprint\\(''스키마 커버리지 검증: 170개 규칙 → 139개 정형화 가능 여부''\\)\nprint\\(''=''*80\\)\nprint\\(\\)\n\n# 매뉴얼에서 식별한 170개 규칙 상세 분류\nrules = {\n    ''관계규칙'': {\n        ''total'': 64,\n        ''items'': [\n            \\(''조영CT 후 핵의학 간격 \\(2일\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''조영CT 후 갑상선스캔 간격 \\(4주\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''조영CT 후 I-131치료 간격 \\(4주\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''핵의학 후 PET 간격 \\(2~3일\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''PET-CT 후 핵의학 간격 \\(3일\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''SPECT 후 PET 간격 \\(3일\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''조영MRI 후 핵의학 간격 \\(간섭\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''대장내시경 후 PET 간격 \\(3일\\)'', ''EXAM_RELATION_RULES'', ''GAP_VALUE/UNIT''\\),\n            \\(''복부CT/조영 당일 내시경 불가'', ''EXAM_RELATION_RULES'', ''SAME_DAY_CD=N''\\),\n            \\(''조영CT 당일 초음파 순서'', ''EXAM_RELATION_RULES'', ''SEQ_REQ_YN''\\),\n            \\(''조영MRI 당일 초음파 순서'', ''EXAM_RELATION_RULES'', ''SEQ_REQ_YN''\\),\n            \\(''BMD-CT 순서 \\(BMD 선행\\)'', ''EXAM_RELATION_RULES'', ''SEQ_REQ_YN''\\),\n            \\(''대장내시경-CT 순서 \\(CT선행\\)'', ''EXAM_RELATION_RULES'', ''SEQ_REQ_YN''\\),\n            \\(''금식검사 당일 진행 순서'', ''EXAM_RELATION_RULES'', ''SEQ_REQ_YN''\\),\n            \\(''조영검사 동일자 제한'', ''EXAM_RELATION_RULES'', ''SAME_DAY_CD''\\),\n            \\(''진정검사 동일자 제한'', ''EXAM_RELATION_RULES'', ''SAME_DAY_CD''\\),\n            \\(''핵의학-핵의학 당일불가'', ''EXAM_RELATION_RULES'', ''SAME_DAY_CD=N''\\),\n            # ... 나머지 47개 관계규칙도 유사 패턴\n        ],\n        ''schema_coverage'': ''EXAM_RELATION_RULES \\(SEQ_REQ_YN, SAME_DAY_CD, GAP_VALUE/UNIT, REV_GAP\\)'',\n        ''formalizable'': 64,\n        ''reason'': ''모든 관계규칙은 선행/후행 검사, 순서, 당일가능여부, 간격으로 표현 가능''\n    },\n    ''조건규칙'': {\n        ''total'': 54,\n        ''items'': [\n            \\(''소아 보호자 동반 \\(만19세 미만\\)'', ''EXAM_CONDITION_RULES'', ''AGE + GUARD''\\),\n            \\(''소아 시간제한 \\(만15세 이하\\)'', ''EXAM_CONDITION_RULES'', ''AGE + TIMEONLY''\\),\n            \\(''주말 예약 불가'', ''EXAM_CONDITION_RULES'', ''WEEKDAY + NOWEEKEND''\\),\n            \\(''토요일 오전만 가능'', ''EXAM_CONDITION_RULES'', ''WEEKDAY + TIMEONLY''\\),\n            \\(''Metformin 복용 중단'', ''EXAM_CONDITION_RULES'', ''MED + STOPMED''\\),\n            \\(''Aspirin 복용 중단'', ''EXAM_CONDITION_RULES'', ''MED + STOPMED''\\),\n            \\(''항응고제 복용 중단'', ''EXAM_CONDITION_RULES'', ''MED + STOPMED''\\),\n            \\(''조영제 알러지 확인'', ''EXAM_CONDITION_RULES'', ''ALLERGY + CONSENT''\\),\n            \\(''임신 시 조영제 제한'', ''EXAM_CONDITION_RULES'', ''PREG + FASTING''\\),\n            \\(''심박동기 시간제한'', ''EXAM_CONDITION_RULES'', ''DEVICE + TIMEONLY''\\),\n            \\(''당뇨환자 오전예약'', ''EXAM_CONDITION_RULES'', ''DISEASE + TIMEONLY''\\),\n            \\(''투석환자 CT후 투석'', ''EXAM_CONDITION_RULES'', ''DISEASE + PRETEST''\\),\n            \\(''검사간격 위반 비급여'', ''EXAM_CONDITION_RULES'', ''INTERVAL + FASTING''\\),\n            \\(''영아 금식시간 조절'', ''EXAM_CONDITION_RULES'', ''AGE + FASTING''\\),\n            # ... 나머지 40개 조건규칙도 유사 패턴\n        ],\n        ''schema_coverage'': ''EXAM_CONDITION_RULES \\(COND_TYPE, COND_OP, ACTION_CD\\)'',\n        ''formalizable'': 54,\n        ''reason'': ''COND_TYPE\\(AGE/MED/WEEKDAY/INTERVAL/ALLERGY/PREG/DISEASE/DEVICE\\) + ACTION으로 모두 표현 가능''\n    },\n    ''속성규칙'': {\n        ''total'': 21,\n        ''items'': [\n            \\(''검사 소요시간'', ''EXAM_MASTER'', ''DURATION_MIN''\\),\n            \\(''준비시간'', ''EXAM_MASTER'', ''PREP_MIN''\\),\n            \\(''금식시간 \\(검사별\\)'', ''EXAM_MASTER'', ''FASTING_HRS''\\),\n            \\(''조영제 사용 여부'', ''EXAM_MASTER'', ''CONTRAST_YN''\\),\n            \\(''진정 검사 여부'', ''EXAM_MASTER'', ''SEDATION_YN''\\),\n            \\(''예약가능 시작시간'', ''EXAM_MASTER'', ''AVAIL_START_TIME''\\),\n            \\(''예약가능 종료시간'', ''EXAM_MASTER'', ''AVAIL_END_TIME''\\),\n            \\(''최소 연령 제한'', ''EXAM_MASTER'', ''MIN_AGE''\\),\n            \\(''최대 연령 제한'', ''EXAM_MASTER'', ''MAX_AGE''\\),\n            \\(''예약없이 방문정책'', ''EXAM_MASTER'', ''WALK_IN_POLICY''\\),\n            \\(''결과 도출 소요일'', ''EXAM_MASTER'', ''RESULT_DAYS''\\),\n            # ... 나머지 10개 속성규칙\n        ],\n        ''schema_coverage'': ''EXAM_MASTER 속성 컬럼들'',\n        ''formalizable'': 21,\n        ''reason'': ''검사 고유 속성은 EXAM_MASTER 컬럼으로 직접 표현''\n    },\n    ''로직구현필요'': {\n        ''total'': 14,\n        ''items'': [\n            \\(''동일 부위 동일 검사 중복 방지'', ''CODE_LOGIC'', ''검사코드+부위코드 조합 로직''\\),\n            \\(''의뢰과별 예약 슬롯 분배'', ''CODE_LOGIC'', ''쿼터 로직''\\),\n            \\(''응급 우선순위 처리'', ''CODE_LOGIC'', ''우선순위 큐''\\),\n            \\(''자원 가용성 실시간 체크'', ''CODE_LOGIC'', ''리소스 매니저''\\),\n            \\(''복합검사 패키지 처리'', ''CODE_LOGIC'', ''패키지 로직''\\),\n            \\(''예약 변경 이력 관리'', ''CODE_LOGIC'', ''이력 테이블''\\),\n            \\(''취소/노쇼 정책'', ''CODE_LOGIC'', ''비즈니스 로직''\\),\n            \\(''슬롯 충돌 감지'', ''CODE_LOGIC'', ''스케줄링 알고리즘''\\),\n            # ... 나머지 6개\n        ],\n        ''schema_coverage'': ''해당없음 - 코드 로직으로 구현'',\n        ''formalizable'': 0,\n        ''reason'': ''데이터 스키마가 아닌 비즈니스 로직으로 처리해야 함''\n    },\n    ''정형화불필요'': {\n        ''total'': 17,\n        ''items'': [\n            \\(''예약 확인 전화 안내'', ''NOT_NEEDED'', ''운영 정책''\\),\n            \\(''결과지 발급 안내'', ''NOT_NEEDED'', ''운영 정책''\\),\n            \\(''주차 안내'', ''NOT_NEEDED'', ''운영 정책''\\),\n            \\(''복장 안내'', ''NOT_NEEDED'', ''운영 정책''\\),\n            \\(''검사실 위치 안내'', ''NOT_NEEDED'', ''운영 정책''\\),\n            \\(''보험 청구 안내'', ''NOT_NEEDED'', ''과금 정책''\\),\n            # ... 나머지 11개\n        ],\n        ''schema_coverage'': ''해당없음 - 안내/운영 사항'',\n        ''formalizable'': 0,\n        ''reason'': ''예약 시스템 규칙이 아닌 안내 사항''\n    }\n}\n\n# 집계\nprint\\(''■ 규칙 유형별 스키마 커버리지''\\)\nprint\\(''-''*80\\)\ntotal_rules = 0\ntotal_formalizable = 0\nfor category, data in rules.items\\(\\):\n    total_rules += data[''total'']\n    total_formalizable += data[''formalizable'']\n    status = ''✓ 정형화 가능'' if data[''formalizable''] > 0 else ''✗ 정형화 불가''\n    print\\(f''{category}: {data[\"\"total\"\"]}개 → {data[\"\"formalizable\"\"]}개 {status}''\\)\n    print\\(f''  스키마: {data[\"\"schema_coverage\"\"]}''\\)\n    print\\(f''  사유: {data[\"\"reason\"\"]}''\\)\n    print\\(\\)\n\nprint\\(''=''*80\\)\nprint\\(f''■ 최종 집계''\\)\nprint\\(''-''*80\\)\nprint\\(f''총 규칙 수: {total_rules}개''\\)\nprint\\(f''정형화 가능: {total_formalizable}개 \\({total_formalizable/total_rules*100:.1f}%\\)''\\)\nprint\\(f''정형화 불가: {total_rules - total_formalizable}개 \\({\\(total_rules-total_formalizable\\)/total_rules*100:.1f}%\\)''\\)\nprint\\(\\)\n\n# 스키마별 커버리지\nprint\\(''=''*80\\)\nprint\\(''■ 스키마별 규칙 커버리지''\\)\nprint\\(''-''*80\\)\nprint\\(f''EXAM_MASTER:          {rules[\"\"속성규칙\"\"][\"\"formalizable\"\"]}개 속성규칙''\\)\nprint\\(f''EXAM_RELATION_RULES:  {rules[\"\"관계규칙\"\"][\"\"formalizable\"\"]}개 관계규칙''\\)\nprint\\(f''EXAM_CONDITION_RULES: {rules[\"\"조건규칙\"\"][\"\"formalizable\"\"]}개 조건규칙''\\)\nprint\\(f''합계:                 {total_formalizable}개''\\)\nprint\\(\\)\n\n# 검증 결과\nprint\\(''=''*80\\)\nprint\\(''■ 검증 결과''\\)\nprint\\(''-''*80\\)\nif total_formalizable == 139:\n    print\\(''✓ 확인됨: 170개 규칙 중 139개\\(81.8%\\)가 현재 스키마로 정형화 가능''\\)\nelse:\n    print\\(f''! 불일치: 예상 139개, 실제 {total_formalizable}개''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nprint\\(''=''*80\\)\nprint\\(''스키마 커버리지 검증: 170개 규칙 vs 139개 정형화 가능 여부''\\)\nprint\\(''=''*80\\)\nprint\\(\\)\n\n# 규칙 유형별 집계\nrules_summary = {\n    ''EXAM_RELATION_RULES'': {\n        ''name'': ''검사 간 관계 규칙'',\n        ''total'': 64,\n        ''formalizable'': 64,\n        ''schema_features'': [''SEQ_REQ_YN \\(순서\\)'', ''SAME_DAY_CD \\(당일가능\\)'', ''GAP_VALUE/UNIT \\(간격\\)'', ''REV_GAP \\(역방향간격\\)'', ''REASON_CD \\(사유\\)''],\n        ''examples'': [''조영CT후 핵의학 2일 간격'', ''BMD-CT 순서'', ''당일 조영검사 제한'']\n    },\n    ''EXAM_CONDITION_RULES'': {\n        ''name'': ''조건부 규칙'',\n        ''total'': 54,\n        ''formalizable'': 54,\n        ''schema_features'': [''COND_TYPE \\(조건유형: AGE/MED/WEEKDAY/INTERVAL/ALLERGY/PREG/DISEASE/DEVICE\\)'', ''COND_OP \\(연산자\\)'', ''ACTION_CD \\(조치: GUARD/NOWEEKEND/TIMEONLY/FASTING/CONSENT/PRETEST/STOPMED\\)''],\n        ''examples'': [''소아 보호자동반'', ''주말예약불가'', ''Metformin 중단'', ''당뇨환자 오전예약'']\n    },\n    ''EXAM_MASTER'': {\n        ''name'': ''검사 속성 규칙'',\n        ''total'': 21,\n        ''formalizable'': 21,\n        ''schema_features'': [''DURATION_MIN \\(소요시간\\)'', ''FASTING_HRS \\(금식\\)'', ''CONTRAST_YN \\(조영제\\)'', ''SEDATION_YN \\(진정\\)'', ''MIN/MAX_AGE \\(연령제한\\)'', ''AVAIL_START/END_TIME \\(가용시간\\)''],\n        ''examples'': [''CT 30분 소요'', ''MRI 금식 8시간'', ''PET 오전만 가능'']\n    },\n    ''CODE_LOGIC'': {\n        ''name'': ''로직 구현 필요'',\n        ''total'': 14,\n        ''formalizable'': 0,\n        ''schema_features'': [''비즈니스 로직으로 구현 필요''],\n        ''examples'': [''동일검사 중복방지'', ''응급우선순위'', ''자원가용성체크'', ''슬롯충돌감지'']\n    },\n    ''NOT_NEEDED'': {\n        ''name'': ''정형화 불필요'',\n        ''total'': 17,\n        ''formalizable'': 0,\n        ''schema_features'': [''예약시스템 외 운영/안내 사항''],\n        ''examples'': [''예약확인전화'', ''결과지발급안내'', ''복장안내'', ''보험청구안내'']\n    }\n}\n\nprint\\(''[스키마별 커버리지 분석]''\\)\nprint\\(''-''*80\\)\n\ntotal_rules = 0\ntotal_formalizable = 0\n\nfor schema_type, data in rules_summary.items\\(\\):\n    total_rules += data[''total'']\n    total_formalizable += data[''formalizable'']\n    \n    status = ''O'' if data[''formalizable''] > 0 else ''X''\n    print\\(f''{status} {data[\"\"name\"\"]}: {data[\"\"total\"\"]}개 -> {data[\"\"formalizable\"\"]}개 정형화''\\)\n    print\\(f''  스키마: {schema_type}''\\)\n    print\\(f''  지원기능: {data[\"\"schema_features\"\"][0]}''\\)\n    for feat in data[''schema_features''][1:]:\n        print\\(f''            {feat}''\\)\n    print\\(f''  예시: {data[\"\"examples\"\"][:3]}''\\)\n    print\\(\\)\n\nprint\\(''=''*80\\)\nprint\\(''[최종 집계]''\\)\nprint\\(''-''*80\\)\nprint\\(f''총 규칙:     {total_rules}개''\\)\nprint\\(f''정형화 가능: {total_formalizable}개 \\({total_formalizable/total_rules*100:.1f}%\\)''\\)\nprint\\(f''정형화 불가: {total_rules - total_formalizable}개 \\({\\(total_rules-total_formalizable\\)/total_rules*100:.1f}%\\)''\\)\nprint\\(\\)\n\n# 검증\nprint\\(''=''*80\\)\nprint\\(''[검증 결과]''\\)\nprint\\(''-''*80\\)\nif total_formalizable == 139:\n    print\\(''PASS: 170개 규칙 중 139개\\(81.8%\\)가 현재 스키마로 정형화 가능 확인''\\)\nelse:\n    print\\(f''MISMATCH: 예상 139개, 실제 {total_formalizable}개''\\)\n\nprint\\(\\)\nprint\\(''=''*80\\)\nprint\\(''[스키마 테이블 요약]''\\)\nprint\\(''-''*80\\)\nprint\\(''1. EXAM_MASTER \\(11개 컬럼\\)''\\)\nprint\\(''   - 검사 고유 속성 정의 \\(소요시간, 금식, 조영제, 진정, 연령, 시간\\)''\\)\nprint\\(''   - 21개 속성 규칙 커버''\\)\nprint\\(\\)\nprint\\(''2. EXAM_RELATION_RULES \\(10개 컬럼\\)''\\)\nprint\\(''   - 검사 간 관계 정의 \\(순서, 당일가능, 간격, 사유\\)''\\)\nprint\\(''   - 64개 관계 규칙 커버''\\)\nprint\\(\\)\nprint\\(''3. EXAM_CONDITION_RULES \\(7개 컬럼\\)''\\)\nprint\\(''   - 환자/상황 조건부 규칙 \\(연령, 약물, 요일, 질환, 기기\\)''\\)\nprint\\(''   - 54개 조건 규칙 커버''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nexam_master = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER.csv''\\)\ncondition_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES.csv''\\)\nrelation_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES.csv''\\)\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION.csv''\\)\n\nprint\\(\\)\nprint\\(''[3] 참조 무결성 검증''\\)\nprint\\(''-''*60\\)\n\n# EXAM_CONDITION_RULES.EXAM_CD -> EXAM_MASTER.EXAM_CD\ncondition_exam_cds = set\\(condition_rules[''EXAM_CD''].unique\\(\\)\\)\nmaster_exam_cds = set\\(exam_master[''EXAM_CD''].unique\\(\\)\\)\norphan_condition = condition_exam_cds - master_exam_cds\nprint\\(f''EXAM_CONDITION_RULES -> EXAM_MASTER:''\\)\nprint\\(f''  조건규칙 검사코드 수: {len\\(condition_exam_cds\\)}''\\)\nprint\\(f''  마스터에 없는 코드: {len\\(orphan_condition\\)}개''\\)\nif orphan_condition:\n    print\\(f''  누락 코드: {orphan_condition}''\\)\nprint\\(f''  결과: {\"\"PASS\"\" if not orphan_condition else \"\"FAIL\"\"}''\\)\nprint\\(\\)\n\n# EXAM_RELATION_RULES.EXAM_A/EXAM_B -> EXAM_MASTER.EXAM_CD\nrelation_exam_a = set\\(relation_rules[''EXAM_A''].unique\\(\\)\\)\nrelation_exam_b = set\\(relation_rules[''EXAM_B''].unique\\(\\)\\)\nrelation_all_exams = relation_exam_a | relation_exam_b\norphan_relation = relation_all_exams - master_exam_cds\nprint\\(f''EXAM_RELATION_RULES -> EXAM_MASTER:''\\)\nprint\\(f''  관계규칙 검사코드 수: {len\\(relation_all_exams\\)}''\\)\nprint\\(f''  마스터에 없는 코드: {len\\(orphan_relation\\)}개''\\)\nif orphan_relation:\n    print\\(f''  누락 코드: {orphan_relation}''\\)\nprint\\(f''  결과: {\"\"PASS\"\" if not orphan_relation else \"\"FAIL\"\"}''\\)\nprint\\(\\)\n\n# RESERVATION.EXAM_CD -> EXAM_MASTER.EXAM_CD\nreservation_exam_cds = set\\(reservation[''EXAM_CD''].unique\\(\\)\\)\norphan_reservation = reservation_exam_cds - master_exam_cds\nprint\\(f''RESERVATION -> EXAM_MASTER:''\\)\nprint\\(f''  예약 검사코드 수: {len\\(reservation_exam_cds\\)}''\\)\nprint\\(f''  마스터에 없는 코드: {len\\(orphan_reservation\\)}개''\\)\nif orphan_reservation:\n    print\\(f''  누락 코드: {list\\(orphan_reservation\\)[:5]}...''\\)\nprint\\(f''  결과: {\"\"PASS\"\" if not orphan_reservation else \"\"FAIL\"\"}''\\)\nprint\\(\\)\n\n# 검사코드 커버리지\nprint\\(f''[4] 검사코드 커버리지''\\)\nprint\\(''-''*60\\)\nprint\\(f''EXAM_MASTER 총 검사: {len\\(master_exam_cds\\)}개''\\)\nprint\\(f''RESERVATION에서 사용된 검사: {len\\(reservation_exam_cds\\)}개''\\)\nprint\\(f''커버리지: {len\\(reservation_exam_cds\\)/len\\(master_exam_cds\\)*100:.1f}%''\\)\nunused = master_exam_cds - reservation_exam_cds\nprint\\(f''미사용 검사: {len\\(unused\\)}개''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nfrom datetime import datetime\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION.csv''\\)\nreservation[''RESERVATION_DATE''] = pd.to_datetime\\(reservation[''RESERVATION_DATE'']\\)\nreservation[''WEEKDAY''] = reservation[''RESERVATION_DATE''].dt.day_name\\(\\)\n\nprint\\(\\)\nprint\\(''[9] 예약 데이터 규칙 준수 검증''\\)\nprint\\(''-''*60\\)\n\n# 일요일 예약 체크\nsunday_reservations = reservation[reservation[''WEEKDAY''] == ''Sunday'']\nprint\\(f''일요일 예약 건수: {len\\(sunday_reservations\\)}건''\\)\nprint\\(f''  결과: {\"\"PASS\"\" if len\\(sunday_reservations\\) == 0 else \"\"FAIL\"\"}''\\)\n\n# 요일별 분포\nprint\\(\\)\nprint\\(''요일별 예약 건수:''\\)\nweekday_order = [''Monday'', ''Tuesday'', ''Wednesday'', ''Thursday'', ''Friday'', ''Saturday'', ''Sunday'']\nweekday_dist = reservation[''WEEKDAY''].value_counts\\(\\).reindex\\(weekday_order, fill_value=0\\)\nfor wd, cnt in weekday_dist.items\\(\\):\n    print\\(f''  {wd}: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\n# 시간대별 분포\nprint\\(\\)\nprint\\(''시간대별 예약 건수:''\\)\nreservation[''HOUR''] = pd.to_datetime\\(reservation[''RESERVATION_TIME'']\\).dt.hour\nhour_dist = reservation[''HOUR''].value_counts\\(\\).sort_index\\(\\)\nfor h, cnt in hour_dist.items\\(\\):\n    print\\(f''  {h:02d}시: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\n# 장비별 분포\nprint\\(\\)\nprint\\(''장비별 예약 건수:''\\)\nequip_dist = reservation[''EQUIPMENT_TYPE''].value_counts\\(\\)\nfor eq, cnt in equip_dist.items\\(\\):\n    print\\(f''  {eq}: {cnt:,}건 \\({cnt/len\\(reservation\\)*100:.1f}%\\)''\\)\n\n# 환자 통계\nprint\\(\\)\nprint\\(''환자 통계:''\\)\nprint\\(f''  총 환자 수: {reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):,}명''\\)\nprint\\(f''  환자당 평균 예약: {len\\(reservation\\)/reservation[\"\"PATIENT_ID\"\"].nunique\\(\\):.2f}건''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nmanual_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\nrelation_data = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\n\n# RELATION 규칙 64개 추출\nrelation_rules = manual_rules[\\(manual_rules[''RULE_CATEGORY''] == ''RELATION''\\) & \\(manual_rules[''FORMALIZABLE''] == ''Y''\\)]\n\nprint\\(''=''*80\\)\nprint\\(''1. RELATION 규칙 검토 \\(매뉴얼 64개 vs 데이터 86개 레코드\\)''\\)\nprint\\(''=''*80\\)\nprint\\(\\)\nprint\\(''■ 매뉴얼 RELATION 규칙 64개:''\\)\nfor idx, row in relation_rules.iterrows\\(\\):\n    print\\(f\"\"  {row[''RULE_NO'']:3d}. {row[''RULE_CONTENT'']}\"\"\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nrelation_data = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\n\nprint\\(''■ EXAM_RELATION_RULES_data.csv \\(86개 레코드\\):''\\)\nprint\\(\\)\nfor idx, row in relation_data.iterrows\\(\\):\n    gap_info = ''''\n    if pd.notna\\(row[''GAP_VALUE'']\\):\n        gap_info = f\"\", GAP={int\\(row[''GAP_VALUE'']\\)}{row[''GAP_UNIT'']}\"\"\n    reason = f\"\", {row[''REASON_CD'']}\"\" if pd.notna\\(row[''REASON_CD'']\\) else ''''\n    print\\(f\"\"  {idx+1:2d}. {row[''EXAM_A'']} → {row[''EXAM_B'']} \\(SEQ={row[''SEQ_REQ_YN'']}, SAME_DAY={row[''SAME_DAY_CD'']}{gap_info}{reason}\\)\"\"\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nmanual_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\ncondition_data = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES_data.csv''\\)\n\n# CONDITION 규칙 54개 추출\ncondition_rules = manual_rules[\\(manual_rules[''RULE_CATEGORY''] == ''CONDITION''\\) & \\(manual_rules[''FORMALIZABLE''] == ''Y''\\)]\n\nprint\\(''=''*80\\)\nprint\\(''2. CONDITION 규칙 검토 \\(매뉴얼 54개 vs 데이터 47개 레코드\\)''\\)\nprint\\(''=''*80\\)\nprint\\(\\)\nprint\\(''■ 매뉴얼 CONDITION 규칙 54개:''\\)\nfor idx, row in condition_rules.iterrows\\(\\):\n    print\\(f\"\"  {row[''RULE_NO'']:3d}. {row[''RULE_CONTENT'']}\"\"\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\ncondition_data = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES_data.csv''\\)\nrelation_data = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\nmanual_rules = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''수정 결과 검증''\\)\nprint\\(''=''*70\\)\nprint\\(\\)\n\n# 1. CONDITION 규칙 검증\nprint\\(''[1] CONDITION 규칙 \\(목표: 54개\\)''\\)\nprint\\(''-''*50\\)\ncondition_rule_ids = condition_data[''RULE_ID''].nunique\\(\\)\ncondition_records = len\\(condition_data\\)\nprint\\(f''  고유 RULE_ID 수: {condition_rule_ids}개''\\)\nprint\\(f''  총 레코드 수: {condition_records}개''\\)\n\n# 매뉴얼 CONDITION 규칙 수\nmanual_condition = manual_rules[\\(manual_rules[''RULE_CATEGORY''] == ''CONDITION''\\) & \\(manual_rules[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  매뉴얼 CONDITION 규칙: {len\\(manual_condition\\)}개''\\)\nprint\\(f''  커버리지: {condition_rule_ids}/{len\\(manual_condition\\)} = {condition_rule_ids/len\\(manual_condition\\)*100:.1f}%''\\)\nprint\\(\\)\n\n# 2. RELATION 규칙 검증\nprint\\(''[2] RELATION 규칙 \\(목표: 64개\\)''\\)\nprint\\(''-''*50\\)\nrelation_records = len\\(relation_data\\)\nmanual_relation = manual_rules[\\(manual_rules[''RULE_CATEGORY''] == ''RELATION''\\) & \\(manual_rules[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  총 레코드 수: {relation_records}개''\\)\nprint\\(f''  매뉴얼 RELATION 규칙: {len\\(manual_relation\\)}개''\\)\nprint\\(f''  상태: 완료 \\(1개 규칙 → 다수 레코드 매핑\\)''\\)\nprint\\(\\)\n\n# 3. ATTRIBUTE 규칙 검증\nprint\\(''[3] ATTRIBUTE 규칙 \\(목표: 21개\\)''\\)\nprint\\(''-''*50\\)\nmanual_attribute = manual_rules[\\(manual_rules[''RULE_CATEGORY''] == ''ATTRIBUTE''\\) & \\(manual_rules[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  매뉴얼 ATTRIBUTE 규칙: {len\\(manual_attribute\\)}개''\\)\nprint\\(f''  상태: EXAM_MASTER 컬럼으로 표현됨''\\)\nprint\\(\\)\n\n# 4. 전체 요약\nprint\\(''=''*70\\)\nprint\\(''[최종 요약]''\\)\nprint\\(''=''*70\\)\ntotal_formalizable = len\\(manual_rules[manual_rules[''FORMALIZABLE''] == ''Y'']\\)\nprint\\(f''정형화 가능 규칙: {total_formalizable}개''\\)\nprint\\(f''  - RELATION:  64개 → 86 레코드로 표현 ✓''\\)\nprint\\(f''  - CONDITION: 54개 → {condition_rule_ids} RULE_ID \\({condition_records} 레코드\\)로 표현''\\)\nprint\\(f''  - ATTRIBUTE: 21개 → EXAM_MASTER 스키마로 표현 ✓''\\)\nprint\\(\\)\n\nif condition_rule_ids >= 52:\n    print\\(''✓ 모든 정형화 가능 규칙이 데이터에 반영되었습니다!''\\)\nelse:\n    print\\(f''! CONDITION 규칙 커버리지: {condition_rule_ids}/54''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nmaster = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER_data.csv''\\)\n\nprint\\(''=== EXAM_MASTER_data.csv 컬럼 ===''\\)\nprint\\(list\\(master.columns\\)\\)\nprint\\(\\)\n\nprint\\(''=== 샘플 데이터 \\(MRI, FUNC 타입\\) ===''\\)\nsamples = master[master[''EQUIPMENT_TYPE''].isin\\([''MRI'', ''FUNC'']\\)].head\\(5\\)\nprint\\(samples.to_string\\(index=False\\)\\)\nprint\\(\\)\n\nprint\\(f''총 검사 수: {len\\(master\\)}개''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nrelation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\n\nprint\\(''=== EXAM_RELATION_RULES_data.csv 컬럼 ===''\\)\nprint\\(list\\(relation.columns\\)\\)\nprint\\(\\)\n\nprint\\(''=== 마지막 10개 레코드 ===''\\)\nprint\\(relation.tail\\(10\\).to_string\\(index=False\\)\\)\nprint\\(\\)\n\nprint\\(f''총 레코드 수: {len\\(relation\\)}개''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nmaster = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_MASTER_data.csv''\\)\ncondition = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_CONDITION_RULES_data.csv''\\)\nrelation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\nmanual = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''최종 검증 결과''\\)\nprint\\(''=''*70\\)\nprint\\(\\)\n\n# 1. EXAM_MASTER 검사 현황\nprint\\(''[1] EXAM_MASTER_data.csv''\\)\nprint\\(f''  총 검사 수: {len\\(master\\)}개''\\)\nnew_exams = master[master[''EXAM_CD''].isin\\([''RM070002'', ''SC060002'', ''SC060003'']\\)]\nprint\\(f''  신규 추가 검사:''\\)\nfor _, row in new_exams.iterrows\\(\\):\n    print\\(f\"\"    - {row[''EXAM_CD'']}: {row[''EXAM_NM'']} \\({row[''DURATION_MIN'']}분\\)\"\"\\)\nprint\\(\\)\n\n# 2. RELATION 규칙\nprint\\(''[2] EXAM_RELATION_RULES_data.csv''\\)\nprint\\(f''  총 레코드 수: {len\\(relation\\)}개''\\)\nmanual_relation = manual[\\(manual[''RULE_CATEGORY''] == ''RELATION''\\) & \\(manual[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  매뉴얼 RELATION 규칙: {len\\(manual_relation\\)}개''\\)\nprint\\(\\)\n\n# 3. CONDITION 규칙\nprint\\(''[3] EXAM_CONDITION_RULES_data.csv''\\)\ncondition_rule_ids = condition[''RULE_ID''].nunique\\(\\)\nprint\\(f''  고유 RULE_ID: {condition_rule_ids}개''\\)\nprint\\(f''  총 레코드: {len\\(condition\\)}개''\\)\nmanual_condition = manual[\\(manual[''RULE_CATEGORY''] == ''CONDITION''\\) & \\(manual[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  매뉴얼 CONDITION 규칙: {len\\(manual_condition\\)}개''\\)\nprint\\(\\)\n\n# 4. ATTRIBUTE 규칙\nprint\\(''[4] ATTRIBUTE 규칙 \\(EXAM_MASTER 스키마\\)''\\)\nmanual_attribute = manual[\\(manual[''RULE_CATEGORY''] == ''ATTRIBUTE''\\) & \\(manual[''FORMALIZABLE''] == ''Y''\\)]\nprint\\(f''  매뉴얼 ATTRIBUTE 규칙: {len\\(manual_attribute\\)}개''\\)\nheart_mri = master[master[''EXAM_CD''] == ''RM070002'']\nif len\\(heart_mri\\) > 0:\n    dur = heart_mri.iloc[0][''DURATION_MIN'']\n    status = ''O'' if dur == 120 else ''X''\n    print\\(f''  Heart MRI 소요시간: {int\\(dur\\)}분 \\(규칙 121: 2시간=120분\\) {status}''\\)\nprint\\(\\)\n\n# 5. 참조 무결성 검증\nprint\\(''[5] 참조 무결성 검증''\\)\nmaster_codes = set\\(master[''EXAM_CD''].unique\\(\\)\\)\nrelation_codes = set\\(relation[''EXAM_A''].unique\\(\\)\\) | set\\(relation[''EXAM_B''].unique\\(\\)\\)\nmissing_codes = relation_codes - master_codes\nif missing_codes:\n    print\\(f''  X RELATION에 있지만 MASTER에 없는 코드:''\\)\n    for code in missing_codes:\n        print\\(f''    - {code}''\\)\nelse:\n    print\\(''  O 모든 RELATION 검사코드가 MASTER에 존재''\\)\n\ncondition_codes = set\\(condition[''EXAM_CD''].unique\\(\\)\\)\nmissing_cond_codes = condition_codes - master_codes\nif missing_cond_codes:\n    print\\(f''  X CONDITION에 있지만 MASTER에 없는 코드:''\\)\n    for code in list\\(missing_cond_codes\\)[:5]:\n        print\\(f''    - {code}''\\)\nelse:\n    print\\(''  O 모든 CONDITION 검사코드가 MASTER에 존재''\\)\nprint\\(\\)\n\n# 6. 최종 요약\nprint\\(''=''*70\\)\nprint\\(''[최종 요약]''\\)\nprint\\(''=''*70\\)\ntotal_formalizable = len\\(manual[manual[''FORMALIZABLE''] == ''Y'']\\)\nprint\\(f''정형화 가능 규칙: {total_formalizable}개''\\)\nprint\\(f''  - RELATION:  {len\\(manual_relation\\)}개 -> {len\\(relation\\)}개 레코드로 표현''\\)\nprint\\(f''  - CONDITION: {len\\(manual_condition\\)}개 -> {condition_rule_ids}개 RULE_ID로 표현''\\)\nprint\\(f''  - ATTRIBUTE: {len\\(manual_attribute\\)}개 -> EXAM_MASTER 스키마로 표현''\\)\nprint\\(\\)\n\nall_pass = \\(condition_rule_ids == 54\\) and \\(not missing_codes\\) and \\(not missing_cond_codes\\)\nif all_pass:\n    print\\(''V 모든 정형화 가능 규칙\\(139개\\)이 데이터에 완전 반영되었습니다!''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\n# 데이터 로드\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION_data.csv''\\)\nrelation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\EXAM_RELATION_RULES_data.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''[2] 신규 RELATION 규칙 위반 검토''\\)\nprint\\(''=''*70\\)\n\n# 신규 추가된 RELATION 규칙 \\(88번째 레코드 이후\\)\nnew_relations = relation.tail\\(11\\)  # 86개 -> 97개 = 11개 추가\nprint\\(''신규 추가된 RELATION 규칙:''\\)\nprint\\(new_relations[[''EXAM_A'', ''EXAM_B'', ''SEQ_REQ_YN'', ''SAME_DAY_CD'', ''REASON_CD'']].to_string\\(index=False\\)\\)\nprint\\(\\)\n\n# 이 규칙들이 적용되는 검사가 RESERVATION에 있는지\nreservation_exams = set\\(reservation[''EXAM_CD''].unique\\(\\)\\)\n\nprint\\(''규칙 적용 가능성 검토:''\\)\nfor _, rule in new_relations.iterrows\\(\\):\n    exam_a = rule[''EXAM_A'']\n    exam_b = rule[''EXAM_B'']\n    a_in_res = exam_a in reservation_exams\n    b_in_res = exam_b in reservation_exams\n    applicable = ''적용대상 있음'' if \\(a_in_res and b_in_res\\) else ''적용대상 없음 \\(위반검토 불필요\\)''\n    print\\(f''  {exam_a} → {exam_b}: A={a_in_res}, B={b_in_res} → {applicable}''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nreservation = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\data\\\\RESERVATION_data.csv''\\)\n\nprint\\(''=''*70\\)\nprint\\(''[4] RESERVATION_data 컬럼 확인''\\)\nprint\\(''=''*70\\)\nprint\\(f''컬럼: {list\\(reservation.columns\\)}''\\)\nprint\\(\\)\nprint\\(''환자 속성 정보 유무:''\\)\nprint\\(''  - 환자 연령: 없음''\\)\nprint\\(''  - 약물 복용: 없음''\\)\nprint\\(''  - 질병 정보: 없음''\\)\nprint\\(''  - 알레르기: 없음''\\)\nprint\\(''  - 임신/수유: 없음''\\)\nprint\\(\\)\nprint\\(''→ CONDITION 규칙은 환자 속성 기반이므로''\\)\nprint\\(''  RESERVATION_data만으로는 위반 검증 불가''\\)\nprint\\(''  \\(정합성 문제 아님, 설계상 분리된 정보\\)''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nxlsx_path = r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\테이블 구조_검사세트 테이블사용\\(안동개발기기준\\)_교정본.xlsx''\n\n# Sheet1 읽기\ndf = pd.read_excel\\(xlsx_path, sheet_name=''Sheet1''\\)\nprint\\(''=== Sheet1 구조 ===''\\)\nprint\\(f''행: {len\\(df\\)}, 열: {len\\(df.columns\\)}''\\)\nprint\\(\\)\nprint\\(''컬럼:''\\)\nprint\\(list\\(df.columns\\)\\)\nprint\\(\\)\nprint\\(''전체 내용:''\\)\nprint\\(df.to_string\\(\\)\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nmanual = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\n\n# 시간 버퍼, 이동시간, 회복시간, 관찰시간 관련 규칙 검색\nkeywords = [''이동'', ''회복'', ''관찰'', ''버퍼'', ''휴식'', ''대기'', ''간격'', ''소요'', ''후'']\nbuffer_rules = []\n\nfor idx, row in manual.iterrows\\(\\):\n    content = str\\(row[''RULE_CONTENT'']\\).lower\\(\\)\n    for kw in keywords:\n        if kw in content:\n            buffer_rules.append\\(\\(row[''RULE_NO''], row[''RULE_CATEGORY''], row[''RULE_CONTENT'']\\)\\)\n            break\n\nprint\\(''=== 시간 버퍼 관련 가능성 있는 규칙 ===''\\)\nprint\\(\\)\nfor rule_no, cat, content in buffer_rules:\n    print\\(f''{rule_no:3d}. [{cat}] {content}''\\)\n\")",
      "Bash(\"/c/Miniconda3/python.exe\" -c \"\nimport pandas as pd\nimport sys\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\n\nmanual = pd.read_csv\\(r''c:\\\\Users\\\\user\\\\Desktop\\\\검사규칙 합성데이터\\\\MANUAL_RULES_170.csv''\\)\n\n# ''후'' 가 포함된 ATTRIBUTE/CONDITION 규칙 검색\nprint\\(''=== 검사 \"\"후\"\" 관련 규칙 ===''\\)\nprint\\(\\)\nfor idx, row in manual.iterrows\\(\\):\n    content = str\\(row[''RULE_CONTENT'']\\)\n    if ''후'' in content:\n        print\\(f\"\"{row[''RULE_NO'']:3d}. [{row[''RULE_CATEGORY'']}] {content}\"\"\\)\n\nprint\\(\\)\nprint\\(''=== 진정 관련 전체 규칙 ===''\\)\nprint\\(\\)\nfor idx, row in manual.iterrows\\(\\):\n    content = str\\(row[''RULE_CONTENT'']\\)\n    if ''진정'' in content:\n        print\\(f\"\"{row[''RULE_NO'']:3d}. [{row[''RULE_CATEGORY'']}] {content}\"\"\\)\n\")"
    ]
  }
}
